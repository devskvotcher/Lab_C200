// Темы:
// Простое наследование. Виртуальные функции. Абстрактные классы.
// Битовые поля.


#include <tchar.h>
#include <iostream>
#include "myString.h"
#include "Shape.h"
#include "Byte.h"
#define	  stop __asm nop
MyString GetMyString(const char *ar[], int totalMemory)
{
	MyString MyStr(totalMemory);
	for (size_t i = 0; i < 6; i++)
	{
		MyStr.ConcatenationString(ar[i]);	
	}
	return MyStr;
}
int NecessaryMemory(const char* str, int& memory)
{
	memory = strlen(str) + 1;
	return memory;
}
int _tmain(int argc, _TCHAR* argv[])
{
	setlocale(LC_ALL, "Rus");
	std::cout << "Задание 1.Массив объектов класса.\n";

	//Задание 1.Массив объектов класса.
	{
		//Объявите и проинициализируйте массив ar из объектов
		// типа MyString. 
		//MyString str1[N]= {...};
		{
		const int N = 3;
		MyString str1[N] = { "C++", "C", "hard" };
		//Проверка - печать строк-членов класса
		for (size_t i = 0; i < N; i++)
		{
			std::cout << str1[i].GetString() << std::endl;
		}
		}
		//Замените размер const int N=5; , не изменяя список инициализаторов.
		{
			const int N = 5;
			MyString str1[N] = { "C++", "C", "hard" };
			for (size_t i = 0; i < N; i++)
			{			
				std::cout << str1[i].GetString() << std::endl;
			}
		}			
	}
	stop


		//Задание 2.Массив указателей на объекты класса.
	{
		std::cout << "Задание 2.Массив указателей на объекты класса.\n";
		//Объявите и проинициализируйте массив arPtr из N
		//указателей на объекты типа MyString (сами объекты 
		//создаются динамически!).
		const int N=3;
		MyString *arPtr[N]={new MyString("C++"), new MyString("C"), new MyString("hard")};
			for (size_t i = 0; i < N; i++)
			{
				std::cout<<arPtr[i]->GetString()<< std::endl;
			}
	//Печать строк-членов класса

   	//Замените размер const int N=5; , не изменяя список инициализаторов.
			{
				const int N = 5;
				MyString* arPtr[N] = { new MyString("C++"), new MyString("C"), new MyString("hard") };
				//for (size_t i = 3; i < N; i++)
				/*{
					arPtr[i] = new MyString();
				}*/
				
				for (size_t i = 0; i < N; i++)
				{
					if (arPtr[i] != nullptr)
					{
						std::cout << arPtr[i]->GetString() << std::endl;
					}
					
				}
				for (size_t i = 0; i < N; i++)
				{
					delete arPtr[i];
				}
			}

	}
		stop
		//А::A(){int x, int y}

	//Задание 3.Простое наследование.Аргументы конструктора,
	// передаваемые в базовый класс.

	//Создайте иерархию классов:
	//базовый класс Shape (который описывает любую фигуру)
	//и два производных класса Rect и Circle.
	//Подумайте: какие данные и методы нужно ввести в базовый
	//и производные классы (например, любую фигуру можно сделать
	//цветной => в базовом классе можно ввести переменную, которая
	//будет определять цвет фигуры.
	//Подсказка: для хранения цвета объявите перечисление (RED,GREEN,BLUE...);



	//В конструкторах производных классов предусмотрите передачу
	//параметра-цвета конструктору базового класса.
	//При создании и уничтожении объекта производного типа определите
	//последовательность вызовов конструкторов и деструкторов базового
	//и производного классов
		std::cout << "Create a Shape-object" << std::endl;
		Shape shape(Shape::COLOR::RED);
		std::cout << "Create a Rect-object" << std::endl;
		Rect rect(2,4,2,4, Shape::COLOR::BLUE);
		std::cout << "Create a Circle-object" << std::endl;
		Circle circle(2, 4, 2, Shape::COLOR::WHITE);
//--------------------//NB.Описать последовательность вызовов конструкторов и деструкторов	



		stop
			//////////////////////////////////////////////////////////////////////

				//Задание 4.Виртуальные функции.
				//4а) Модифицируйте классы Shape,Rect и Circle:
				//добавьте в каждый класс public метод void WhereAmI().
				//Реализация каждой функции должна выводить сообщение 
				//следующего вида "Now I am in class Shape(Rect или Circle)".
				//Выполните приведенный фрагмент, объясните результат.

			std::cout << "Задание 4а" << std::endl;
	{
		Shape s(Shape::COLOR::RED);
		Rect r(2, 4, 2, 4, Shape::COLOR::BLUE);
		Circle c(2, 4, 2, Shape::COLOR::WHITE);

		std::cout << "Вызов посредством прямого обращения к объекту" << std::endl;
		//Метод какого класса вызывается в следующих строчках???
		s.WhereAmI();	//	Класса Shape
		r.WhereAmI();	//	Класса Shape, но переопределнного в классе Circle
		c.WhereAmI();	//	Класса Shape, но переопределнного в классе Rect
		stop

			std::cout << "Вызов посредством указателя" << std::endl;
		Shape* pShape = &s;
		Shape* pRect = &r;
		Shape* pCircle = &c;
    	pShape->WhereAmI();	//	Класса Shape
		pRect->WhereAmI();	//	Класса Rect, ибо в указатель базового класса положена ссылка на наследуемый класс.
		pCircle->WhereAmI(); //	Класса Circle, ибо в указатель базового класса положена ссылка на наследуемый класс.
		stop

			std::cout << "Вызов посредством ссылки" << std::endl;
		Shape &rShape = s;
		Shape& rRect = r;
		Shape& rCircle = c;
        rShape.WhereAmI();	//вызов посредством rShape	Класс Shape
		rRect.WhereAmI();	//вызов посредством	rRect	Класс Rect
		rCircle.WhereAmI(); //вызов посредством rCircle	Класс Circle
		stop
	}
	std::cout << "Задание 4б" << std::endl;
	//4б) Добавьте в базовый и производные классы виртуальный
	// метод WhereAmIVirtual(). По аналогии с 4а вызовите
	// виртуальный метод посредством объектов, указателей и
	// ссылок, определенных в предыдущем фрагменте.
	//Выполните новый фрагмент, объясните разницу.
	{
		Shape s(Shape::COLOR::RED);
		Rect r(2, 4, 2, 4, Shape::COLOR::BLUE);
		Circle c(2, 4, 2, Shape::COLOR::WHITE);

		std::cout << "Вызов посредством прямого обращения к объекту" << std::endl;
		//Метод какого класса вызывается в следующих строчках???
		s.WhereAmIVirtual();	//	Класса Shape
		r.WhereAmIVirtual();	//	Класса Shape, но переопределнного в классе Circle
		c.WhereAmIVirtual();	//	Класса Shape, но переопределнного в классе Rect
		stop

			std::cout << "Вызов посредством указателя" << std::endl;
		Shape* pShape = &s;
		Shape* pRect = &r;
		Shape* pCircle = &c;
		pShape->WhereAmIVirtual();	//	Класса Shape
		pRect->WhereAmIVirtual();	//	Класса Rect, ибо в указатель базового класса положена ссылка на наследуемый класс.
		pCircle->WhereAmIVirtual(); //	Класса Circle, ибо в указатель базового класса положена ссылка на наследуемый класс.
		stop

			std::cout << "Вызов посредством ссылки" << std::endl;
		Shape& rShape = s;
		Shape& rRect = r;
		Shape& rCircle = c;
		rShape.WhereAmIVirtual();	//вызов посредством rShape	Класс Shape
		rRect.WhereAmIVirtual();	//вызов посредством	rRect	Класс Rect
		rCircle.WhereAmIVirtual(); //вызов посредством rCircle	Класс Circle
		stop
	}


//////////////////////////////////////////////////////////////////////
//*
	std::cout << "Задание №5.Виртуальные деструкторы." << std::endl;
	{
	//Задание 5.Виртуальные деструкторы.
	//Модифицируйте классы:
	//a) введите соответствующие
	// деструкторы (без ключевого слова virtual).
	//Реализация каждого деструктора
	//должна выводить сообщение следующего вида
	// "Now I am in Shape's destructor!" или
	// "Now I am in Rect's destructor!"
	//Выполните фрагмент. Объясните результат.
		Shape s(Shape::COLOR::RED);
		Rect r(2, 4, 2, 4, Shape::COLOR::BLUE);
		Circle c(2, 4, 2, Shape::COLOR::WHITE);
		/*
		* Конструктор базового класса Shape
		* 
				Конструктор базового класса Shape
					Конструктор наследуемого класса Rect

						Конструктор базового класса Shape
							Конструктор наследуемого класса Circle

							Деструктор наследуемого класса Circle
						Деструктор базового класса Shape

					Деструктор наследуемого класса Rect
				Деструктор базового класса Shape

			Деструктор базового класса Shape
			Деструктор наследуемого класса Circle
			Деструктор базового класса Shape
			Деструктор наследуемого класса Rect
			Деструктор базового класса Shape
			Деструктор базового класса Shape
		*/
	// b) Добавьте в объявление деструкторов ключевое слово virtual 
	//Выполните фрагмент.Объясните разницу.
		/*
		* Конструктор базового класса Shape
				Конструктор базового класса Shape
						Конструктор наследуемого класса Rect

							Конструктор базового класса Shape
								Конструктор наследуемого класса Circle
								Деструктор наследуемого класса Circle
							Деструктор базового класса Shape
						Деструктор наследуемого класса Rect
				Деструктор базового класса Shape

Деструктор базового класса Shape
Деструктор наследуемого класса Circle
Деструктор базового класса Shape
Деструктор наследуемого класса Rect
Деструктор базового класса Shape
Деструктор базового класса Shape
		*/
	//------//NB-------Разницы почему-то не получилось, однако она должна быть и обусловлена тем, что без виртуального
		//деструктора возикает утечка памяти, потому что деструктор базового класса не знает о существования деструктора
		//наследуемого класса
	
	//Подумайте: какие конструкторы вызываются в следующей строке?
		//Если в разработанных классов каких-то конструкторов
		//не хватает - реализуйте
		//Если Вы считаете, что в приведенном фрагменте чего-то
		//не хватает - добавьте
		{

			Rect r(2, 4, 2, 4, Shape::COLOR::BLUE);
			Shape* ar[] = { new Shape(r), new Rect(r), new Circle(r), new Circle() };
			//Вызовите для каждого элемента массива метод WhereAmIVirtual()
			for (size_t i = 0; i < 4; i++)
			{
				ar[i]->WhereAmIVirtual();
			}
			for (size_t i = 0; i < 4; i++)
			{
				delete ar[i];
			}

			//sifeof(ar)/sizeof(ar[0])
		}
	}
		
	

	stop
		//*/

		/*
			//Задание 6*. В чем заключается отличие 1) и 2)
			{
				Shape* pShapes = new Rect[10];//1)
				Rect* pRects = new Rect[10];//2)

				//Попробуйте вызвать метод WhereAmIVirtual() для каждого элемента обоих массивов -
				//в чем заключается проблема???


				//Освободите динамически захваченную память

			}

		*/

		//////////////////////////////////////////////////////////////////////
		std::cout << "Задание 7.Виртуальные функции и оператор разрешения области видимости. " << std::endl;
	//Задание 7.Виртуальные функции и оператор разрешения области видимости. 

	{
		Rect r(2, 4, 2, 4, Shape::BLACK);
		Shape* p = &r;
		p->WhereAmIVirtual(); //Rect
		stop
	}

	{
		Rect r(2,4,2,4,Shape::BLACK);
		Shape* p = &r;	
		p->WhereAmIVirtual(); //Rect
		stop


			//4a Оператор разрешения области видимости.
			//Посредством объекта r и указателя p вызовите виртуальную функцию
			//WhereAmIVirtual()класса Shape
			p->Shape::WhereAmIVirtual();
		
	}


//////////////////////////////////////////////////////////////////////

	//Задание 8.Чисто виртуальные функции. 
	//Введите в базовый класс метод void Inflate(int); Подумайте:
	//можно ли реализовать такой метод для базового класса? => как его нужно объявить.
	//Реализуйте этот метод для производных классов.
	{
		Rect r(2, 4, 2, 4, Shape::BLACK);
		Shape* p = &r;
		p->Inflate(5);
		Circle c(2,5,5,Shape::GREEN);
		p = &c;
		p->Inflate(5);
	}



//////////////////////////////////////////////////////////////////////
	//Задание 9. Создайте глобальную функцию, которая будет принимать любое
	//количество указателей на строки, а возвращать объект MyString,
	//в котором строка будет конкатенацией параметров

	//Определяем необходимое количество выделяемой памяти
	const char* ar[] = { "Hi", "C++", "C", "is", "very", "hard", "language","*"};
	
	int totalMemory = 0;
	for (size_t i = 0; i < sizeof(ar)/sizeof(ar[0]); i++)
	{
		int memory = 0;
		totalMemory += NecessaryMemory(ar[i], memory);
	}
	std::cout << "Необходимый объем памяти=" << totalMemory << std::endl;
	MyString str = GetMyString(ar, totalMemory);
	std::cout<<str.GetString()<<std::endl;
	//for (size_t i = 0; i < 8/*sizeof(ar) / sizeof(ar[0])*/; i++)
	//{
	  MyString str1 = str1.f(ar[0], ar[1],"abc","*");
	  std::cout << str1.GetString() << std::endl;
	//}
	
	// Выделяем память и конкатенируем строку
////////////////////////////////////////////////////////////////////////

	//Задание 10.Объединения (union) C++. Битовые поля.
	//1.
	//Создайте следующие классы для различных представлений значений байта:
	//Bin - для двоичного представления
	//Hex - для шестнадцатерчного представления
	//Oct - для восьмеричного представления.
	//Подсказка 1: - для удобства используйте битовые поля.
	//Подсказка 2: - конструкторов в таких вспомогательных классах быть не должно,
	//так как все они будут членами объединения (union).
	//2.
	//В каждом классе введите метод Show, который должен выводить значение в
	//соответствующем виде
	//3.
	//Посредством объединения MyByte предоставьте пользователю возможность манипулировать
	//одним и тем же значением по-разному:
	//а) выводить: десятичное, шестнадцатеричное, восьмеричное, двоичное значение байта 
	//          а также символ, соответствующий хранимому значению (если есть соответствие);
	//б) выводить отдельные (указанные посредством параметра) шестнадцатеричные,
	//			восьмеричные, двоичные цифры;
	//в) изменять отдельные двоичные, восьмеричные или шестнадцатеричные цифры;

	Bytes byte(0x1f);
	byte.ShowHex();
	byte.ShowDec();
	byte.ShowChar();
	byte.ShowHexPos(1);
	byte.EditHex(1, 0xA);
	byte.ShowHex();
	byte.ShowDec();

	Bytes octi(0233);
	octi.ShowOct();
	octi.ShowDec();
	octi.ShowChar();
	octi.ShowOctPos(0);
	octi.EditOct(2, 0);
	octi.ShowOct();
	octi.ShowDec();

	Bytes bini(0b10001110);
	bini.ShowBin();
	bini.ShowDec();
	bini.ShowChar();
	bini.EditBin(5, 0);
	bini.ShowBin();
	bini.ShowDec();

	//...



	return 0;
}//endmain

