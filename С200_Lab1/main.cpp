#include "myRect.h"
#include "myString.h"
#include <iostream>
#include "Bochka.h"



#define stop __asm nop

int main()
{
	using namespace std;
	/*
		//Задание 1.Объявление класса. Создание экземпляра класса.
		//Вызов методов класса.
		//Откройте закладку Class View - (здесь Вы увидите имена методов и
		//данных - классов Rect и MyString)
		//Обратите внимание на пиктограммы слева от имен членов класса - они
		//обозначают спецификатор доступа к каждому члену класса.

		//Какой конструктор вызывается при создании экземпляра класса?
		// При создании класса вызывается конструктор по умолчанию
		*/
	{
		Rect rect;
		stop
	}

	/*
	//1a. Объявите и определите конструктор с параметрами для
	//инициализации переменных класса. Создайте экземляры класса Rect
	//с помощью конструктора с параметрами. Если компилятор выдает
	//ошибку в предыдущем фрагменте, подумайте - чего ему не
	//хватает? Добейтесь отсутствия ошибок.
	//Выполняя задание с самого начала по шагам, определите:
	//в какой момент происходит вызов конструктора(какого?)?

	//Замечание*: хорошо было бы учесть тот факт, что прямоугольник
	//может оказаться "ненормализованным", то есть m_left>m_right или/и
	//m_top>m_bottom
	//Подсказка: учтите, что пользователь Вашего класса может указывать
	//в качестве параметров любые значения! Например:
	*/
	Rect R(4, 3, 2, 1);

	stop
		/*
	//1б. При конструировании объекта посредством конструктора без параметров
	//предусмотрите инициализацию переменных класса, например, нулем
	*/
		Rect rect;

	stop
		/*
	//1в. Объявите, определите и вызовите метод класса InflateRect(),
	//который увеличивает размеры прямоугольника на заданные приращения
	//(раздвигая стороны от центра - каждую сторону на свое значение).
	//Подсказка: объявить и определить методы можно не только "вручную",
	//но и с помощью Wizard-a Class View. Для этого: откройте закладку
	//ClassView окна проекта, сделайте активным класс Rect и нажмите
	//правую кнопку мыши - в появившемся контекстном меню выберите
	//Add/Add Member Function... С помощью появившейся диалоговой панели
	//"дайте указания" Wizard-у как объявить и определить метод.

	*/
		R.InflateRect(1, 1, -1, 1);
	stop

		/*
			//Задание 2.Перегрузка конструкторов и методов класса.
			//Конструктор копирования.

			//2а.Объявите и определите конструктор копирования в классе Rect.
			//Выполняя задание по шагам, определите, какой
			//конструктор вызывается при создании r1,r2,r3 и r4?
			//Чему равны переменные созданных объектов?
			*/
	{
	Rect r1;									// конструктор по умолчанию со значениями 0,1,1,0 
	//r1.printCoord();
	Rect r2(1, 2, 3, 4);						// конструктор с параметрами 1,2,3,4
	//r2.printCoord();
	Rect r3 = r1;								// констуктор копирования , копия r1
	//r3.printCoord();
	Rect r4(r2);								// конструктор копирования  r2.
	//r4.printCoord();
	stop



		//2б. Объявите и определите в классе Rect метод InflateRect(),
		  //который принимает два аргумента, по умолчанию равных 1, и 
		  //раздвигает стороны прямоугольника на на заданные приращения.
		  //Для каких объектов вызывается функция InflateRect()?
	r1.InflateRect(1, 1);						//1,1,0,0
	r2.InflateRect(2, 2);						//2,2,0,0
	//Какая из функций InflateRect() вызывается в каждом из трех случаев?
	r3.InflateRect(2, 2, 2, 2);					//	2,2,2,2
	r3.InflateRect(3, 3);						// 3,3,0,0
	r3.InflateRect(5);							//  5,1,0,0
	r3.InflateRect();							// все значения по умолчанию
	stop

	}

	//Задание 3.Спецификаторы доступа. Инкапсуляция. 
	{
	Rect r;
	//Раскомментируйте следующую строку. Объясните ошибку
	//компилятора

	//int tmp = r.m_left;  // m_left private




	//Введите в класс Rect метод void SetAll(...),
	//который присваивают переменным класса передаваемые
	//значения. Вызовите созданный метод, проверьте корректность. 

	r.SetAll(5, 6, 7, 8);	


	//Введите в класс Rect парный метод GetAll(...),
	//который "достает" значения private-переменных класса.
	//Вызовите созданный метод, проверьте корректность. 
	int left, right, top, bottom;
	r.GetAll(left, right, top, bottom);
	std::cout << "left = " << left << "\nright = " << right << "\ntop = " << top << "\nbottom = " << bottom << std::endl;
	system("pause");

	stop
	}


	//Задание 4.Передача экземпляра класса в качестве параметра
	//функции. Возвращение объекта класса по значению. Поставив
	//остановы в конструкторе копирования или выполняя фрагмент
	//по шагам, определите: в какой момент происходит обращение
	//к конструктору копирования. 
	//Создайте глобальную функцию 
	// Rect BoundingRect(Rect, Rect);
	//которая принимает два объекта класса Rect по значению и
	//возвращает объект класса Rect, который является прямоугольником,
	//в который вписаны заданные прямоугольники. Как происходит
	//передача параметров и возвращение объекта класса?



	{

		Rect r1(1, 2, 3, 4), r2(5, 6, 7, 8), r3;

		r3 = BoundingRect(r1, r2);
		std::cout << "Function value\n";
		int left, right, top, bottom;
		r3.GetAll(left, right, top, bottom);		
		std::cout << "left = " << left << "\nright = " << right << "\ntop = " << top << "\nbottom = " << bottom << std::endl;
		system("pause");
		stop

		//Задание 4а. Передача объектов по ссылке.
		//Создайте глобальную функцию BoundingRect2, которая выполняет ту же
		//задачу, принимая параметры по ссылке
		//Вызываются ли конструкторы при передаче параметров?		

		r3 = BoundingRect2(r1, r2);
		std::cout << "Function link\n";		
		r3.GetAll(left, right, top, bottom);
		std::cout << "left = " << left << "\nright = " << right << "\ntop = " << top << "\nbottom = " << bottom << std::endl;
		system("pause");

		stop
	}

	//Задание 4б.Реализуйте ту же задачу (BoundingRect) методом класса
	{
	std::cout << "Method\n";
	Rect r1(1, 2, 3, 4), r2(5, 6, 7, 8), r3;	
	int left, right, top, bottom;
	r3=r2.BoundingRect(r1);	
	r3.GetAll(left, right, top, bottom);
	std::cout << "left = " << left << "\nright = " << right << "\ntop = " << top << "\nbottom = " << bottom << std::endl;
	system("pause");
	stop
	}


	//Задание 5. Когда вызываются конструкторы и деструкторы.
	//Объявите и определите
	//явный деструктор класса. Поставьте остановы в 
	//конструкторе (конструкторах) и деструкторе. Определите: когда для
	//каждого из объектов вызывается конструктор, а когда - деструктор?
	{
		Rect r1;
		Rect*	pR = new Rect(1,2,1,2);	
		{
			Rect r2(r1);
			Rect arRect[2];
			for(int i=0; i<3; i++)
			{
				static Rect r3 (i,i,i,i) ;
				Rect r4(*pR);
				Rect r5(i,i,i,i);
			}
		}
		delete pR;	
		stop
	}

 
	//Задание 6.Конструктор + деструктор = функциональное
	// замыкание. Класс MyString
	// Посредством конструктора (конструкторов) и деструктора обеспечьте
	//корректные инициализацию и деактивацию объекта
	//C помощью остановов определите когда происходит
	//захват и освобождение памяти для строки-члена класса
	{
		MyString	str1("It's my string1!");
		//Создайте метод GetString(), который обеспечит доступ к хранящейся строке.
		//С помощью cout и метода GetString() распечатайте строку объекта str1
		//Замечание: подумайте, как следует корректно реализовать метод GetString().

		//Подсказка 1:
		//приведенный ниже код должен работать:
		std::cout<<str1.GetString()<<std::endl;

		//Подсказка 2:
		//приведенный ниже код НЕ должен работать:
		//str1.GetString()[1] = 'W';

		//Подсказка 3:
		//приведенный ниже код должен работать:
		const MyString	str2("It's my string2!");
		std::cout<<str2.GetString()<<std::endl;
		system("pause");
	}
	stop


	//6a. Раскомментируйте следующий фрагмент. Подумайте - какие
	//неприятности Вас ожидают. Попробуйте исправить положение (как?)

		// Такой способ только для простых объектров ожидает падение программы. 
		// Компилятор переписывает адрес одного и того же динамически выделенного блока памяти 
		// А потом по закрывающей скобке будут вызваны деструкторы.
		// Первый деструктор освободит блок памяти, адрес станет недействительным.
		// При попытке вызвать деструктор для несуществующего блока памяти(вторичный вызов). Будет ошибка времени выполнения. 
		//Необходимо сделать конструктор копирования.
		{
			MyString str1("The first string!");
			MyString str2 = str1;

			// проверка корректности через вывод на экран.
			std::cout << str2.GetString() << std::endl; 
			system("pause");
		}
		stop

	//6б. Реализуйте метод SetNewString, который будет заменять строку
	// на новую
		{
				MyString str1("The first string!");
				str1.SetNewString("New String!");

				// проверка корректности через вывод на экран.
				std::cout << str1.GetString() << std::endl;
				system("pause");
		}
			stop

			//Задание 7.  Решите с помощью классов следующую задачу:
			//даны две бочки известного объема. В одной бочке в начальный момент
			//времени содержится спирт (96%), в другой – вода.
			//Кружкой емкостью 1л переливаем итеративно содержимое из одной бочки
			//в другую следующим способом: на каждой итерации
			//зачерпнули из первой бочки -> вылили во вторую
			//зачерпнули из второй бочки -> вылили в первую.
			//Требуется определить номер итерации, на которой концентрация спирта в
			//первой бочке станет меньше 50%.

			//Bochka spirt(...);
			//Bochka water(...);
			//...
			//	while(концентрация спирта в бочке spirt > 50%)
			//	{
			//		spirt.Pereliv(water); //или spirt.Pereliv(water, объем_кружки);
			//		water.Pereliv(spirt); // аналогично
			//		...

			//	} 159

		{
			Bochka spirt(96,1,100);
			Bochka water(0,1,100);				
			int count = 0;   //счетчик итераций
			while (spirt.GetConcentration()> 50)
			{				
				spirt.Pereliv(water);
				water.Pereliv(spirt);
				count++;
			}
				
			std::cout << "Kol-vo iteration = " << count << endl;
		}

return 0;

}//end_main

